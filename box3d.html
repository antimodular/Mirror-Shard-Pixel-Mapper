<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mirror Shard 3D Box View</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container3d {
            width: 100vw;
            height: 100vh;
        }
        #sourceFrame {
            position: absolute;
            top: 0;
            left: 0;
            width: 3840px;
            height: 2160px;
            border: none;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Line2 dependencies in correct order -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/Line2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
</head>
<body>
        <!-- Hidden file input for loading images -->
    <input type="file" id="imageInput" accept="image/*" style="display: none;">
    <div id="container3d"></div>
    <iframe id="sourceFrame" src="index.html"></iframe>

    <script>
        const VERSION = 'v5.8';
        console.log(`===== box3d.html ${VERSION} =====`);
        console.log('Quadrant mapping with horizontal flip for front/back');
        console.log('Portrait walls: 9 wide × 16 tall');
        console.log('Floor: Camera view reconstruction with centered masks');

        let scene, camera, renderer, controls;
        let boxGroup;
        let floorMesh = null;
        let floorCanvas = null;
        let floorCtx = null;
        let sourceCanvas = null;
        let iframeShards = null;
        let iframeWindow = null;
        let texturesReady = false;
        let updateInterval = null;
        let gui = null;
        let gridHelper = null;
        let customSourceCanvas = null;  // For loaded images
        let wallOutlines = [];  // Line objects for wall borders
        let wallSegmentOutlines = [];  // Line objects for wall segment outlines
        let floorSegmentOutlines = [];  // Line objects for floor segment outlines

        // GUI settings
        const guiSettings = {
            showWalls: true,
            showFloor: true,
            showGrid: false,
            showWallOutlines: false,
            showWallSegments: false,
            showFloorSegments: false,
            lineWidth: 1,
            debugColors: false,
            // Quadrant mapping: which source quadrant (0-3) goes to which wall
            // Quadrants: 0=TL, 1=TR, 2=BL, 3=BR
            frontQuadrant: 1,  // TR
            rightQuadrant: 3,  // BR
            backQuadrant: 2,   // BL
            leftQuadrant: 0,   // TL
            // Flip settings for walls that need horizontal mirroring
            flipFront: true,
            flipBack: true,
            // Background gray value (0-255)
            bgGray: 0,  // Default black
            loadImage: function() {
                document.getElementById('imageInput').click();
            }
        };

        // Unique colors for each shard (for debug mode)
        const shardColors = [
            [1.0, 0.0, 0.0],   // 0: Red
            [0.0, 1.0, 0.0],   // 1: Green
            [0.0, 0.0, 1.0],   // 2: Blue
            [1.0, 1.0, 0.0],   // 3: Yellow
            [1.0, 0.0, 1.0],   // 4: Magenta
            [0.0, 1.0, 1.0],   // 5: Cyan
            [1.0, 0.5, 0.0],   // 6: Orange
            [0.5, 0.0, 1.0],   // 7: Purple
            [0.0, 0.5, 0.5],   // 8: Teal
            [0.5, 0.5, 0.0],   // 9: Olive
            [0.5, 0.0, 0.0],   // 10: Maroon
            [0.0, 0.5, 0.0],   // 11: Dark Green
            [1.0, 0.5, 0.5],   // 12: Light Red
            [0.5, 0.5, 1.0],   // 13: Light Blue
        ];

        // Wall dimensions (in 3D units)
        const wallWidth = 9;
        const wallHeight = 16;

        // Camera/floor canvas resolution
        // Based on actual mask point coordinate ranges: X(1287-2840), Y(211-1743)
        // We'll use the full camera resolution and offset to center the content
        const CAMERA_WIDTH = 2880;   // Approximate camera width
        const CAMERA_HEIGHT = 1800;  // Approximate camera height
        const FLOOR_RES_W = CAMERA_WIDTH;
        const FLOOR_RES_H = CAMERA_HEIGHT;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            const halfWidth = wallWidth / 2;

            // Camera - positioned to see box with floor inside
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 30, 0.1);  // Directly above, looking down at floor
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container3d').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);  // Look at floor center
            controls.minDistance = 1;
            controls.maxDistance = 40;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // Create box group
            boxGroup = new THREE.Group();
            scene.add(boxGroup);

            // Create the 4-wall box with portrait walls
            createPortraitWallBox();

            // Create wall outlines (initially hidden)
            createWallOutlines();

            // Setup dat.GUI
            setupGUI();

            // Setup file input handler
            setupFileInput();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Wait for iframe to load, then start capturing
            const iframe = document.getElementById('sourceFrame');
            iframe.addEventListener('load', () => {
                console.log('Source iframe loaded');

                // Wait a bit for WebGL to initialize in the iframe
                setTimeout(() => {
                    tryConnectToSource();
                }, 2000);
            });

            // Animation loop
            animate();

            console.log('3D Box initialized');
        }

        function createWallOutlines() {
            const halfWidth = wallWidth / 2;

            // Wall positions and rotations (matching wall creation)
            const wallConfigs = [
                { pos: [0, wallHeight / 2, halfWidth], rot: [0, 0, 0] },           // Front
                { pos: [halfWidth, wallHeight / 2, 0], rot: [0, -Math.PI / 2, 0] }, // Right
                { pos: [0, wallHeight / 2, -halfWidth], rot: [0, Math.PI, 0] },     // Back
                { pos: [-halfWidth, wallHeight / 2, 0], rot: [0, Math.PI / 2, 0] }  // Left
            ];

            wallConfigs.forEach((config, index) => {
                // Create rectangle outline for each wall using Line2 (fat lines)
                const hw = wallWidth / 2;
                const hh = wallHeight / 2;
                // Line2 uses flat position array [x1,y1,z1, x2,y2,z2, ...]
                const positions = [
                    -hw, -hh, 0,
                    hw, -hh, 0,
                    hw, hh, 0,
                    -hw, hh, 0,
                    -hw, -hh, 0  // Close the loop
                ];

                const geometry = new THREE.LineGeometry();
                geometry.setPositions(positions);

                const material = new THREE.LineMaterial({
                    color: 0xffffff,
                    linewidth: guiSettings.lineWidth,  // LineMaterial uses pixels
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                });

                const line = new THREE.Line2(geometry, material);
                line.computeLineDistances();
                line.position.set(...config.pos);
                line.rotation.set(...config.rot);
                line.visible = guiSettings.showWallOutlines;
                boxGroup.add(line);
                wallOutlines.push(line);
            });
        }

        function updateSegmentOutlines() {
            // Clear existing segment outlines
            wallSegmentOutlines.forEach(line => boxGroup.remove(line));
            wallSegmentOutlines = [];
            floorSegmentOutlines.forEach(line => boxGroup.remove(line));
            floorSegmentOutlines = [];

            if (!iframeShards || iframeShards.length === 0) return;

            // Ensure floor offsets are calculated
            calculateFloorOffsets(iframeShards);

            const halfWidth = wallWidth / 2;

            // Floor geometry dimensions (must match createPortraitWallBox)
            // Square floor that fits inside the box
            const floorSize = wallWidth;

            // Create floor segment outlines using Line2 (fat lines)
            if (guiSettings.showFloorSegments) {
                iframeShards.forEach((shard, index) => {
                    if (!shard.maskPoints || shard.maskPoints.length < 3) return;

                    // Offset and scale mask points to floor 3D space
                    // Use uniform scale to maintain aspect ratio, fit to square
                    const scale = floorSize / Math.max(FLOOR_RES_W, FLOOR_RES_H);
                    const positions = [];
                    shard.maskPoints.forEach(p => {
                        const centeredX = p.x + floorOffsetX - FLOOR_RES_W / 2;
                        const centeredY = p.y + floorOffsetY - FLOOR_RES_H / 2;
                        const x = centeredX * scale;
                        const z = centeredY * scale;
                        positions.push(x, 0.02, z);
                    });
                    // Close the loop
                    const firstX = positions[0], firstY = positions[1], firstZ = positions[2];
                    positions.push(firstX, firstY, firstZ);

                    const geometry = new THREE.LineGeometry();
                    geometry.setPositions(positions);

                    const material = new THREE.LineMaterial({
                        color: 0xffffff,
                        linewidth: guiSettings.lineWidth,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                    });

                    const line = new THREE.Line2(geometry, material);
                    line.computeLineDistances();
                    boxGroup.add(line);
                    floorSegmentOutlines.push(line);
                });
            }

            // Create wall segment outlines using Line2 (fat lines)
            if (guiSettings.showWallSegments) {
                // Shard coordinates are always in 3840x2160 space (calibration reference)
                const REF_WIDTH = 3840;
                const REF_HEIGHT = 2160;
                const refQuadrantWidth = REF_WIDTH / 2;   // 1920
                const refQuadrantHeight = REF_HEIGHT / 2; // 1080

                // Configurable quadrant mapping: which source quadrant goes to which wall
                const quadrantMapping = [
                    guiSettings.frontQuadrant,
                    guiSettings.rightQuadrant,
                    guiSettings.backQuadrant,
                    guiSettings.leftQuadrant
                ];

                // Create reverse lookup: sourceQuadrant -> wallIndex
                const quadrantToWall = {};
                quadrantMapping.forEach((sourceQuadrant, wallIndex) => {
                    quadrantToWall[sourceQuadrant] = wallIndex;
                });

                // Wall configs matching wall positions
                const wallConfigs = [
                    { pos: [0, wallHeight / 2, halfWidth + 0.01], rot: [0, 0, 0] },           // Front
                    { pos: [halfWidth + 0.01, wallHeight / 2, 0], rot: [0, -Math.PI / 2, 0] }, // Right
                    { pos: [0, wallHeight / 2, -halfWidth - 0.01], rot: [0, Math.PI, 0] },     // Back
                    { pos: [-halfWidth - 0.01, wallHeight / 2, 0], rot: [0, Math.PI / 2, 0] }  // Left
                ];

                // Determine which quadrant each shard belongs to based on transformedMaskPoints
                iframeShards.forEach((shard, index) => {
                    if (!shard.transformedMaskPoints || shard.transformedMaskPoints.length < 3) return;

                    // Get centroid of transformed mask to determine source quadrant
                    const centroid = getPolygonCentroid(shard.transformedMaskPoints);
                    const sourceQuadrant = getQuadrantFromPoint(centroid, REF_WIDTH, REF_HEIGHT);

                    // Find which wall displays this source quadrant
                    const wallIndex = quadrantToWall[sourceQuadrant];
                    if (wallIndex === undefined) return;  // No wall configured for this quadrant

                    // Check if this wall needs horizontal flipping
                    const needsFlip = (wallIndex === 0 && guiSettings.flipFront) ||
                                      (wallIndex === 2 && guiSettings.flipBack);

                    const config = wallConfigs[wallIndex];
                    const qx = (sourceQuadrant % 2) * refQuadrantWidth;
                    const qy = Math.floor(sourceQuadrant / 2) * refQuadrantHeight;

                    // Transform mask points to wall local coordinates (with 90° CCW rotation)
                    // Build flat position array for Line2
                    const positions = [];
                    shard.transformedMaskPoints.forEach(p => {
                        const lx = p.x - qx;
                        const ly = p.y - qy;
                        // For 90° CCW rotation: new_x = ly, new_y flipped for correct alignment
                        let wx = (ly / refQuadrantHeight - 0.5) * wallWidth;
                        const wy = (lx / refQuadrantWidth - 0.5) * wallHeight;
                        // Apply horizontal flip if needed
                        if (needsFlip) {
                            wx = -wx;
                        }
                        positions.push(wx, wy, 0);
                    });
                    // Close the loop
                    const firstX = positions[0], firstY = positions[1], firstZ = positions[2];
                    positions.push(firstX, firstY, firstZ);

                    const geometry = new THREE.LineGeometry();
                    geometry.setPositions(positions);

                    const material = new THREE.LineMaterial({
                        color: 0xffffff,
                        linewidth: guiSettings.lineWidth,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                    });

                    const line = new THREE.Line2(geometry, material);
                    line.computeLineDistances();
                    line.position.set(...config.pos);
                    line.rotation.set(...config.rot);
                    boxGroup.add(line);
                    wallSegmentOutlines.push(line);
                });
            }
        }

        function getQuadrantFromPoint(point, width, height) {
            const halfW = width / 2;
            const halfH = height / 2;
            if (point.x < halfW && point.y < halfH) return 0;  // TL
            if (point.x >= halfW && point.y < halfH) return 1; // TR
            if (point.x < halfW && point.y >= halfH) return 2; // BL
            return 3; // BR
        }

        function setupGUI() {
            gui = new dat.GUI({ autoPlace: true });
            gui.domElement.style.marginTop = '50px';

            // Version at top of GUI
            const versionObj = { version: 'v5.9' };
            gui.add(versionObj, 'version').name('Version').listen();

            // Walls folder
            const wallsFolder = gui.addFolder('Walls');

            wallsFolder.add(guiSettings, 'showWalls').name('Show Walls').onChange((value) => {
                const walls = boxGroup.userData.walls;
                if (walls) {
                    walls.front.visible = value;
                    walls.right.visible = value;
                    walls.back.visible = value;
                    walls.left.visible = value;
                }
            });

            wallsFolder.add(guiSettings, 'showWallOutlines').name('Wall Borders').onChange((value) => {
                wallOutlines.forEach(line => line.visible = value);
            });

            wallsFolder.add(guiSettings, 'showWallSegments').name('Shard Outlines').onChange((value) => {
                updateSegmentOutlines();
            });

            wallsFolder.open();

            // Floor folder
            const floorFolder = gui.addFolder('Floor');

            floorFolder.add(guiSettings, 'showFloor').name('Show Floor').onChange((value) => {
                if (floorMesh) floorMesh.visible = value;
            });

            floorFolder.add(guiSettings, 'showFloorSegments').name('Shard Outlines').onChange((value) => {
                updateSegmentOutlines();
            });

            floorFolder.open();

            // Settings folder
            const settingsFolder = gui.addFolder('Settings');

            settingsFolder.add(guiSettings, 'showGrid').name('Show Grid').onChange((value) => {
                if (gridHelper) gridHelper.visible = value;
            });

            settingsFolder.add(guiSettings, 'lineWidth', 1, 10, 1).name('Line Width').onChange((value) => {
                // Update all outline line widths (Line2 uses pixels)
                wallOutlines.forEach(line => {
                    line.material.linewidth = value;
                    line.material.needsUpdate = true;
                });
                wallSegmentOutlines.forEach(line => {
                    line.material.linewidth = value;
                    line.material.needsUpdate = true;
                });
                floorSegmentOutlines.forEach(line => {
                    line.material.linewidth = value;
                    line.material.needsUpdate = true;
                });
            });

            settingsFolder.add(guiSettings, 'debugColors').name('Debug Colors').onChange((value) => {
                // Update both floor and wall textures to show/hide debug colors
                updateFloorTexture();
                updateWallTextures();
            });

            settingsFolder.add(guiSettings, 'bgGray', 0, 255, 1).name('Background').onChange((value) => {
                const gray = value / 255;
                scene.background = new THREE.Color(gray, gray, gray);
            });

            settingsFolder.open();

            // Source folder
            const sourceFolder = gui.addFolder('Source Image');
            sourceFolder.add(guiSettings, 'loadImage').name('Load New 4K Image...');
            sourceFolder.open();

            // Close the GUI panel by default
            gui.close();
        }

        function setupFileInput() {
            const fileInput = document.getElementById('imageInput');
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                console.log(`Loading image: ${file.name}`);

                const reader = new FileReader();
                reader.onload = async (event) => {
                    const dataUrl = event.target.result;

                    // Load the image into the iframe's shader pipeline
                    if (iframeWindow && iframeWindow.loadCustomImage) {
                        const success = await iframeWindow.loadCustomImage(dataUrl);
                        if (success) {
                            console.log('Custom image loaded into shader pipeline');
                        } else {
                            console.error('Failed to load custom image into shader');
                        }
                    } else {
                        console.error('iframe loadCustomImage not available');
                    }
                };
                reader.readAsDataURL(file);

                // Reset file input so same file can be loaded again
                fileInput.value = '';
            });
        }

        function tryConnectToSource() {
            try {
                const iframe = document.getElementById('sourceFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeWindow = iframe.contentWindow;
                sourceCanvas = iframeDoc.getElementById('canvas');

                if (sourceCanvas && sourceCanvas.width > 0) {
                    console.log(`Connected to source canvas: ${sourceCanvas.width}x${sourceCanvas.height}`);

                    // Create floor canvas
                    floorCanvas = document.createElement('canvas');
                    floorCanvas.width = FLOOR_RES_W;
                    floorCanvas.height = FLOOR_RES_H;
                    floorCtx = floorCanvas.getContext('2d');

                    // Start periodic texture updates
                    let shardCheckCount = 0;
                    updateInterval = setInterval(() => {
                        updateWallTextures();
                        // Get shards from iframe if not yet available
                        if (!iframeShards) {
                            shardCheckCount++;
                            if (iframeWindow.shards && iframeWindow.shards.length > 0) {
                                iframeShards = iframeWindow.shards;
                                console.log(`Got ${iframeShards.length} shards with mask data after ${shardCheckCount} checks`);
                                // Update segment outlines if enabled
                                updateSegmentOutlines();
                            } else if (shardCheckCount <= 30 && shardCheckCount % 10 === 0) {
                                console.log(`Checking for shards... (${shardCheckCount})`);
                            }
                        }
                        updateFloorTexture();
                    }, 100); // 10 FPS update

                    updateWallTextures();
                    updateFloorTexture();
                } else {
                    console.log('Canvas not ready, retrying...');
                    setTimeout(tryConnectToSource, 1000);
                }
            } catch (e) {
                console.error('Cannot access iframe canvas (CORS?):', e);
            }
        }

        // Offset to center mask content on floor canvas
        // Camera space bounds: X(1287-2840), Y(211-1743)
        // Center of content: (~2063, ~977)
        // We need to shift content so it's centered on the floor canvas
        let floorOffsetX = 0;
        let floorOffsetY = 0;
        let floorOffsetsCalculated = false;

        function calculateFloorOffsets(shards) {
            if (floorOffsetsCalculated || !shards || shards.length === 0) return;

            // Find bounding box of all mask points
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            shards.forEach(shard => {
                if (!shard.maskPoints) return;
                shard.maskPoints.forEach(p => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                });
            });

            // Calculate offset to center content on floor canvas
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;
            const canvasCenterX = FLOOR_RES_W / 2;
            const canvasCenterY = FLOOR_RES_H / 2;

            floorOffsetX = canvasCenterX - contentCenterX;
            floorOffsetY = canvasCenterY - contentCenterY;

            console.log(`Floor content bounds: (${minX.toFixed(0)}, ${minY.toFixed(0)}) to (${maxX.toFixed(0)}, ${maxY.toFixed(0)})`);
            console.log(`Centering offset: (${floorOffsetX.toFixed(0)}, ${floorOffsetY.toFixed(0)})`);

            floorOffsetsCalculated = true;
        }

        // WebGL floor renderer with proper homography
        let floorScene, floorCamera, floorRenderTarget;
        let floorSourceTexture;
        let floorWebGLInitialized = false;

        function initFloorWebGL() {
            if (floorWebGLInitialized) return;

            // Use square render target to match square floor mesh
            const floorRenderSize = Math.max(FLOOR_RES_W, FLOOR_RES_H);

            // Render target for floor texture (use main renderer)
            floorRenderTarget = new THREE.WebGLRenderTarget(floorRenderSize, floorRenderSize, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });

            // Orthographic camera for 2D rendering - square, centered
            const halfSize = floorRenderSize / 2;
            floorCamera = new THREE.OrthographicCamera(-halfSize, halfSize, halfSize, -halfSize, -1, 1);
            floorCamera.position.z = 1;

            // Scene for floor rendering
            floorScene = new THREE.Scene();
            floorScene.background = new THREE.Color(0x000000);

            floorWebGLInitialized = true;
            console.log('Floor WebGL initialized');
        }

        // Homography shader for floor
        const floorVertexShader = `
            varying vec2 vFloorCoord;
            void main() {
                // Pass actual vertex position as floor coordinates
                vFloorCoord = position.xy;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const floorFragmentShader = `
            precision highp float;
            uniform sampler2D sourceTexture;
            uniform vec2 sourceResolution;
            uniform mat3 homography;
            uniform bool debugMode;
            uniform vec3 debugColor;

            varying vec2 vFloorCoord;

            void main() {
                // Debug mode: show solid color
                if (debugMode) {
                    gl_FragColor = vec4(debugColor, 1.0);
                    return;
                }

                // Apply homography to get source coordinates
                vec3 srcHomog = homography * vec3(vFloorCoord, 1.0);
                vec2 srcCoord = srcHomog.xy / srcHomog.z;

                // Convert to normalized texture coordinates
                vec2 texCoord = srcCoord / sourceResolution;

                // Flip Y because Canvas texture has Y=0 at top, WebGL has Y=0 at bottom
                texCoord.y = 1.0 - texCoord.y;

                // Check bounds
                if (texCoord.x < 0.0 || texCoord.x > 1.0 || texCoord.y < 0.0 || texCoord.y > 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                }

                gl_FragColor = texture2D(sourceTexture, texCoord);
            }
        `;

        function computeHomography3x3(srcPoints, dstPoints) {
            // Compute 3x3 homography matrix from 4 point correspondences
            // srcPoints/dstPoints are arrays of {x, y}
            const src = srcPoints;
            const dst = dstPoints;

            // Build the 8x9 matrix for homography computation
            const A = [];
            for (let i = 0; i < 4; i++) {
                const sx = src[i].x, sy = src[i].y;
                const dx = dst[i].x, dy = dst[i].y;
                A.push([-sx, -sy, -1, 0, 0, 0, sx * dx, sy * dx, dx]);
                A.push([0, 0, 0, -sx, -sy, -1, sx * dy, sy * dy, dy]);
            }

            // Solve using SVD-like approach (simplified Gaussian elimination)
            const h = solveHomography(A);

            // Return as 3x3 matrix (column-major for Three.js)
            return new THREE.Matrix3().set(
                h[0], h[1], h[2],
                h[3], h[4], h[5],
                h[6], h[7], h[8]
            );
        }

        function solveHomography(A) {
            // Gaussian elimination to solve Ah = 0, with h[8] = 1
            const n = 8;
            const m = 9;
            const matrix = A.map(row => [...row]);

            // Forward elimination
            for (let col = 0; col < n; col++) {
                // Find pivot
                let maxRow = col;
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(matrix[row][col]) > Math.abs(matrix[maxRow][col])) {
                        maxRow = row;
                    }
                }
                [matrix[col], matrix[maxRow]] = [matrix[maxRow], matrix[col]];

                if (Math.abs(matrix[col][col]) < 1e-10) continue;

                // Eliminate
                for (let row = col + 1; row < n; row++) {
                    const factor = matrix[row][col] / matrix[col][col];
                    for (let j = col; j < m; j++) {
                        matrix[row][j] -= factor * matrix[col][j];
                    }
                }
            }

            // Back substitution with h[8] = 1
            const h = new Array(9).fill(0);
            h[8] = 1;

            for (let row = n - 1; row >= 0; row--) {
                let sum = 0;
                for (let col = row + 1; col < m; col++) {
                    sum += matrix[row][col] * h[col];
                }
                if (Math.abs(matrix[row][row]) > 1e-10) {
                    h[row] = -sum / matrix[row][row];
                }
            }

            return h;
        }

        function updateFloorTexture() {
            if (!floorMesh || !sourceCanvas || !renderer) return;

            // Initialize WebGL floor renderer if needed
            if (!floorWebGLInitialized) {
                initFloorWebGL();
            }

            // Update source texture from iframe canvas
            if (!floorSourceTexture) {
                floorSourceTexture = new THREE.CanvasTexture(sourceCanvas);
            } else {
                floorSourceTexture.image = sourceCanvas;
                floorSourceTexture.needsUpdate = true;
            }

            // Clear scene
            while (floorScene.children.length > 0) {
                const child = floorScene.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                floorScene.remove(child);
            }

            if (!iframeShards || iframeShards.length === 0) {
                // No shards - render black
                renderer.setRenderTarget(floorRenderTarget);
                renderer.clear();
                renderer.setRenderTarget(null);
            } else {
                // Calculate centering offset
                calculateFloorOffsets(iframeShards);

                const sourceW = sourceCanvas.width;
                const sourceH = sourceCanvas.height;

                console.log(`Rendering ${iframeShards.length} shards to floor, source: ${sourceW}x${sourceH}`);

                // Create a mesh for each shard with homography shader
                iframeShards.forEach((shard, index) => {
                    if (!shard.maskPoints || shard.maskPoints.length < 4) {
                        console.log(`Shard ${index}: not enough maskPoints`);
                        return;
                    }
                    if (!shard.transformedMaskPoints || shard.transformedMaskPoints.length < 4) {
                        console.log(`Shard ${index}: not enough transformedMaskPoints`);
                        return;
                    }

                    // Transform to centered coordinates and flip Y for WebGL
                    const toCentered = (p) => ({
                        x: p.x + floorOffsetX - FLOOR_RES_W / 2,
                        y: -(p.y + floorOffsetY - FLOOR_RES_H / 2)  // Flip Y
                    });

                    // Use first 4 points for homography (quad)
                    // Homography maps floor coords (centered) to source coords
                    const srcPts = shard.transformedMaskPoints.slice(0, 4);
                    const dstPtsCentered = shard.maskPoints.slice(0, 4).map(toCentered);

                    // Compute homography: centered floor coords -> source coords
                    const homography = computeHomography3x3(dstPtsCentered, srcPts);

                    if (index === 0) {
                        console.log(`Shard 0 homography:`, homography.elements);
                    }

                    // Create geometry for the shard polygon (centered coords)
                    const shape = new THREE.Shape();
                    const centeredMask = shard.maskPoints.map(toCentered);
                    shape.moveTo(centeredMask[0].x, centeredMask[0].y);
                    for (let i = 1; i < centeredMask.length; i++) {
                        shape.lineTo(centeredMask[i].x, centeredMask[i].y);
                    }
                    shape.closePath();

                    const geometry = new THREE.ShapeGeometry(shape);

                    const color = shardColors[index % shardColors.length];
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            sourceTexture: { value: floorSourceTexture },
                            sourceResolution: { value: new THREE.Vector2(sourceW, sourceH) },
                            homography: { value: homography },
                            debugMode: { value: guiSettings.debugColors },
                            debugColor: { value: new THREE.Vector3(color[0], color[1], color[2]) }
                        },
                        vertexShader: floorVertexShader,
                        fragmentShader: floorFragmentShader,
                        transparent: true
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    floorScene.add(mesh);

                    if (index === 0) {
                        console.log(`Shard 0 mesh added, vertices:`, geometry.attributes.position.count);
                    }
                });

                console.log(`Floor scene has ${floorScene.children.length} meshes`);

                // Render to target using main renderer
                renderer.setRenderTarget(floorRenderTarget);
                renderer.render(floorScene, floorCamera);
                renderer.setRenderTarget(null);
            }

            // Update floor mesh with render target texture
            if (floorMesh.material.map && floorMesh.material.map !== floorRenderTarget.texture) {
                floorMesh.material.map.dispose();
            }
            floorMesh.material.dispose();

            floorMesh.material = new THREE.MeshBasicMaterial({
                map: floorRenderTarget.texture,
                side: THREE.DoubleSide
            });
        }

        function getPolygonCentroid(points) {
            let cx = 0, cy = 0;
            for (const p of points) {
                cx += p.x;
                cy += p.y;
            }
            return { x: cx / points.length, y: cy / points.length };
        }

        function getBounds(points) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function createPortraitWallBox() {
            const halfWidth = wallWidth / 2;

            console.log(`Creating box with portrait walls: ${wallWidth}w × ${wallHeight}h`);

            // Placeholder materials with colors (will be replaced with textures)
            const materials = [
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }), // Front - Red
                new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }), // Right - Green
                new THREE.MeshBasicMaterial({ color: 0x0000ff, side: THREE.DoubleSide }), // Back - Blue
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })  // Left - Yellow
            ];

            // Front wall (quadrant 0 - TL)
            const frontWall = new THREE.Mesh(
                new THREE.PlaneGeometry(wallWidth, wallHeight),
                materials[0]
            );
            frontWall.position.set(0, wallHeight / 2, halfWidth);
            frontWall.userData = { quadrant: 0, name: 'Front' };
            boxGroup.add(frontWall);

            // Right wall (quadrant 1 - TR)
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(wallWidth, wallHeight),
                materials[1]
            );
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(halfWidth, wallHeight / 2, 0);
            rightWall.userData = { quadrant: 1, name: 'Right' };
            boxGroup.add(rightWall);

            // Back wall (quadrant 2 - BL)
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(wallWidth, wallHeight),
                materials[2]
            );
            backWall.rotation.y = Math.PI;
            backWall.position.set(0, wallHeight / 2, -halfWidth);
            backWall.userData = { quadrant: 2, name: 'Back' };
            boxGroup.add(backWall);

            // Left wall (quadrant 3 - BR)
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(wallWidth, wallHeight),
                materials[3]
            );
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-halfWidth, wallHeight / 2, 0);
            leftWall.userData = { quadrant: 3, name: 'Left' };
            boxGroup.add(leftWall);

            // Floor grid
            gridHelper = new THREE.GridHelper(wallWidth * 2, 18, 0x333333, 0x222222);
            gridHelper.visible = guiSettings.showGrid;
            boxGroup.add(gridHelper);

            // Create square floor that fits inside the box
            const floorSize = wallWidth;  // Square floor matching box width
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
            const floorMaterial = new THREE.MeshBasicMaterial({
                color: 0x333333,
                side: THREE.DoubleSide
            });
            floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;  // Lay flat
            floorMesh.position.y = 0.01;  // Slightly above grid
            boxGroup.add(floorMesh);
            console.log(`Floor: ${floorSize} × ${floorSize} (square)`);

            // Store wall references
            boxGroup.userData.walls = {
                front: frontWall,
                right: rightWall,
                back: backWall,
                left: leftWall
            };
            boxGroup.userData.floor = floorMesh;

            console.log(`Box created: ${wallWidth}×${wallHeight}×${wallWidth} (w×h×d)`);
            console.log('Floor added for source image display');
        }

        function updateWallTextures() {
            if (!sourceCanvas || !boxGroup) return;

            try {
                // Source is 3840x2160 (4K), split into 4 quadrants of 1920x1080 each
                const quadrantWidth = sourceCanvas.width / 2;   // 1920 (landscape width)
                const quadrantHeight = sourceCanvas.height / 2; // 1080 (landscape height)

                // Reference dimensions for shard coordinates (always 3840x2160)
                const REF_WIDTH = 3840;
                const REF_HEIGHT = 2160;
                const refQuadrantWidth = REF_WIDTH / 2;   // 1920
                const refQuadrantHeight = REF_HEIGHT / 2; // 1080

                const walls = boxGroup.userData.walls;
                const wallArray = [walls.front, walls.right, walls.back, walls.left];

                // Configurable quadrant mapping: which source quadrant goes to which wall
                const quadrantMapping = [
                    guiSettings.frontQuadrant,
                    guiSettings.rightQuadrant,
                    guiSettings.backQuadrant,
                    guiSettings.leftQuadrant
                ];

                // Quadrant layout in source:
                // [0: TL] [1: TR]
                // [2: BL] [3: BR]
                // Each quadrant is 1920x1080 (landscape 16:9)
                // Walls are 9x16 (portrait 9:16)
                // So we rotate each quadrant 90° CCW to fit

                wallArray.forEach((wall, wallIndex) => {
                    // Get the source quadrant for this wall from the mapping
                    const sourceQuadrant = quadrantMapping[wallIndex];

                    // Check if this wall needs horizontal flipping
                    const needsFlip = (wallIndex === 0 && guiSettings.flipFront) ||
                                      (wallIndex === 2 && guiSettings.flipBack);

                    // Create a canvas with ROTATED dimensions (portrait)
                    // After 90° rotation: 1080 wide × 1920 tall
                    const qCanvas = document.createElement('canvas');
                    qCanvas.width = quadrantHeight;   // 1080 (becomes width after rotation)
                    qCanvas.height = quadrantWidth;   // 1920 (becomes height after rotation)
                    const qCtx = qCanvas.getContext('2d');

                    if (guiSettings.debugColors && iframeShards && iframeShards.length > 0) {
                        // Debug mode: draw colored polygons for each shard in this quadrant
                        qCtx.fillStyle = '#000000';
                        qCtx.fillRect(0, 0, qCanvas.width, qCanvas.height);

                        // Quadrant origin in reference coords (use sourceQuadrant)
                        const qx = (sourceQuadrant % 2) * refQuadrantWidth;
                        const qy = Math.floor(sourceQuadrant / 2) * refQuadrantHeight;

                        iframeShards.forEach((shard, shardIndex) => {
                            if (!shard.transformedMaskPoints || shard.transformedMaskPoints.length < 3) return;

                            // Check if this shard belongs to the source quadrant
                            const centroid = getPolygonCentroid(shard.transformedMaskPoints);
                            const shardQuadrant = getQuadrantFromPoint(centroid, REF_WIDTH, REF_HEIGHT);
                            if (shardQuadrant !== sourceQuadrant) return;

                            // Get debug color
                            const color = shardColors[shardIndex % shardColors.length];
                            const colorStr = `rgb(${Math.round(color[0]*255)}, ${Math.round(color[1]*255)}, ${Math.round(color[2]*255)})`;

                            // Transform points to rotated wall canvas coordinates
                            // 1. Subtract quadrant origin to get local coords (0-1920, 0-1080)
                            // 2. Apply 90° CCW rotation: new_x = old_y, new_y = quadrantWidth - old_x
                            // 3. Apply horizontal flip if needed
                            qCtx.beginPath();
                            shard.transformedMaskPoints.forEach((p, i) => {
                                const lx = p.x - qx;  // Local x in quadrant (0 to refQuadrantWidth)
                                const ly = p.y - qy;  // Local y in quadrant (0 to refQuadrantHeight)

                                // Scale to actual canvas quadrant size
                                const scaledX = lx * (quadrantWidth / refQuadrantWidth);
                                const scaledY = ly * (quadrantHeight / refQuadrantHeight);

                                // 90° CCW rotation for portrait orientation
                                let rx = scaledY;
                                const ry = quadrantWidth - scaledX;

                                // Apply horizontal flip if needed
                                if (needsFlip) {
                                    rx = qCanvas.width - rx;
                                }

                                if (i === 0) {
                                    qCtx.moveTo(rx, ry);
                                } else {
                                    qCtx.lineTo(rx, ry);
                                }
                            });
                            qCtx.closePath();
                            qCtx.fillStyle = colorStr;
                            qCtx.fill();
                        });
                    } else {
                        // Normal mode: draw source texture
                        // Calculate source position for this quadrant (use sourceQuadrant)
                        const sx = (sourceQuadrant % 2) * quadrantWidth;
                        const sy = Math.floor(sourceQuadrant / 2) * quadrantHeight;

                        // Rotate 90° counter-clockwise:
                        // 1. Translate to center of destination
                        // 2. Rotate -90° (CCW)
                        // 3. Apply horizontal flip if needed
                        // 4. Draw image centered

                        qCtx.save();
                        // Move to center of destination canvas
                        qCtx.translate(qCanvas.width / 2, qCanvas.height / 2);
                        // Apply horizontal flip if needed (before rotation affects different axis)
                        if (needsFlip) {
                            qCtx.scale(-1, 1);
                        }
                        // Rotate 90° CCW (-π/2)
                        qCtx.rotate(-Math.PI / 2);
                        // Draw the quadrant centered (offset by half its original dimensions)
                        qCtx.drawImage(
                            sourceCanvas,
                            sx, sy, quadrantWidth, quadrantHeight,
                            -quadrantWidth / 2, -quadrantHeight / 2, quadrantWidth, quadrantHeight
                        );
                        qCtx.restore();
                    }

                    // Create/update texture
                    const texture = new THREE.CanvasTexture(qCanvas);
                    texture.needsUpdate = true;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;

                    // Dispose old material if it has a texture
                    if (wall.material.map) {
                        wall.material.map.dispose();
                    }
                    wall.material.dispose();

                    // Apply new material with texture
                    wall.material = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });
                });

                if (!texturesReady) {
                    texturesReady = true;
                    console.log('Wall textures updated (rotated 90° CCW to portrait)');
                }
            } catch (e) {
                console.error('Error updating textures:', e);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update LineMaterial resolution for all Line2 objects
            const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
            wallOutlines.forEach(line => {
                line.material.resolution = resolution;
            });
            wallSegmentOutlines.forEach(line => {
                line.material.resolution = resolution;
            });
            floorSegmentOutlines.forEach(line => {
                line.material.resolution = resolution;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

